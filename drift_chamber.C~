// drift_chamber_sim.cc
// Compile with: g++ drift_chamber_sim.cc `pkg-config --cflags --libs garfield++` -o drift_sim
// Or use your Garfield++ CMake as appropriate.

#include <iostream>
#include <vector>
#include <memory>

#include "Garfield/MediumMagboltz.hh"
#include "Garfield/ComponentAnsys121.hh" // If using FEM mesh. (optional)
#include "Garfield/ComponentAnalyticField.hh"
#include "Garfield/Sensor.hh"
#include "Garfield/ViewField.hh"
#include "Garfield/ViewSignal.hh"
#include "Garfield/ViewDrift.hh"
#include "Garfield/AvalancheMicroscopic.hh"
#include "Garfield/SystemOfUnits.hh"
#include "Garfield/Plotting.hh"

using namespace Garfield;

int main() {
    // --- Geometry / geometry parameters (change as needed) ---
    const int nStrips = 71;
    const double pitch = 1.0 * mm;
    const double stripWidth = 0.9 * pitch;
    const double topY = 10.0 * mm;
    const double midY = 0.0 * mm;
    const double botY = -10.0 * mm;
    const double leftX = 0.0 * mm; // leftmost strip center at x=0 (you can shift)
    const double wireRadius = 25.0e-3 * mm; // 25 um
    const double zExtent = 1.0 * mm; // unit depth (2D sim)

    // --- Potentials (user specification) ---
    // Top & bottom planes: strips 1..71. First strip (index 0) = -0.5 kV,
    // strip index 3 (4th strip) = 0 V, last strip index nStrips-1 = -4 kV.
    const double V_first = -0.5 * kilovolt;
    const double V_fourth = 0.0 * volt;
    const double V_last = -4.0 * kilovolt;

    // Middle plane wires potentials:
    const double V_wire_near = -0.5 * kilovolt; // parallel to first strip
    const double V_wire_anode = 1.5 * kilovolt; // parallel to 4th strip (readout)
    const double V_wire_far = -4.0 * kilovolt;  // parallel to last strip

    // --- Create analytic field component (2D approximation using infinite strips/wires) ---
    // NOTE: ComponentAnalyticField supports adding strips/wires in simple geometries.
    auto comp = std::make_shared<ComponentAnalyticField>();

    // Create top and bottom strip arrays and assign potentials strip-by-strip.
    std::vector<double> stripPosX(nStrips);
    for (int i = 0; i < nStrips; ++i) {
        // Center x position of each strip
        stripPosX[i] = (leftX + i * pitch);
    }

    // Build potential arrays for top/bottom strips:
    std::vector<double> potentials(nStrips, 0.0);

    // For indices 0..3 (strips 1..4): interpolate from V_first to V_fourth
    for (int i = 0; i <= 3; ++i) {
        double t = (double)i / 3.0;
        potentials[i] = V_first + t * (V_fourth - V_first);
    }
    // For indices 3..(nStrips-1): interpolate from V_fourth to V_last
    for (int i = 3; i < nStrips; ++i) {
        double t = (double)(i - 3) / (double)(nStrips - 1 - 3);
        potentials[i] = V_fourth + t * (V_last - V_fourth);
    }

    // Add strips to the component: top plane (y = topY)
    for (int i = 0; i < nStrips; ++i) {
        const double cx = stripPosX[i];
        const double left = cx - stripWidth/2.0;
        const double right = cx + stripWidth/2.0;
        // ComponentAnalyticField::AddPlaneStrip expects coordinates and potential - API may differ.
        // Here we call a generic AddRectangleElectrode (pseudocode - adapt if your Garfield++ version uses different names).
        comp->AddRectangleElectrode(left, topY - 0.01*mm, right, topY + 0.01*mm, potentials[i]);
    }

    // Add bottom plane strips (mirror in y)
    for (int i = 0; i < nStrips; ++i) {
        const double cx = stripPosX[i];
        const double left = cx - stripWidth/2.0;
        const double right = cx + stripWidth/2.0;
        comp->AddRectangleElectrode(left, botY - 0.01*mm, right, botY + 0.01*mm, potentials[i]);
    }

    // --- Middle plane: add three wires at x positions parallel to strips 0, 3, last ---
    const double wire1_x = stripPosX[0];
    const double wire2_x = stripPosX[3];
    const double wire3_x = stripPosX[nStrips - 1];

    // ComponentAnalyticField::AddWire(center_x, center_y, z, radius, potential)
    comp->AddWire(wire1_x, midY, 0.0, wireRadius, V_wire_near);
    comp->AddWire(wire2_x, midY, 0.0, wireRadius, V_wire_anode);
    comp->AddWire(wire3_x, midY, 0.0, wireRadius, V_wire_far);

    // Attach component to sensor
    auto sensor = std::make_shared<Sensor>();
    sensor->AddComponent(comp.get());

    // Assign readout to the anode wire (we use the second wire as the signal electrode)
    // The AddElectrode method in Sensor expects an object pointer or an electrode id; here we register the anode wire:
    // Note: Depending on Garfield++ version you may need to get the electrode id from comp.
    int anodeId = comp->GetNumberOfWires() - 2; // this is heuristic; confirm via comp API in your version
    sensor->AddElectrode(comp.get(), anodeId); // adapt this call to the precise API

    // --- Define gas / medium for drift (optional) ---
    auto gas = std::make_shared<MediumMagboltz>();
    gas->SetComposition("ar", 70.0);
    gas->SetComposition("co2", 30.0);
    gas->SetTemperature(293.15); // K
    gas->SetPressure(760.0); // Torr ~ 1 atm (adapt to correct units if library asks mbar)
    gas->Initialise(true);

    comp->SetMedium(gas.get());

    // Setup plotting (ROOT canvases) - plotting field and signal
    ViewField viewField;
    viewField.SetComponent(comp.get());
    viewField.SetNumberOfContours(50);

    // Draw a field map (x from left..right, y from bot..top)
    const double xmin = stripPosX.front() - 2 * pitch;
    const double xmax = stripPosX.back() + 2 * pitch;
    const double ymin = botY - 5 * mm;
    const double ymax = topY + 5 * mm;
    viewField.PlotContour(xmin, ymin, xmax, ymax);

    // --- Simulate a single electron drift from some start point and compute induced signal on anode ---
    // Choose start point near the far cathode side or mid-gap
    double start_x = wire2_x; // start at anode x
    double start_y = midY + 5.0*mm; // 5 mm above middle plane

    // Create avalanche / microscopic transport object (no ionisation avalanche by default)
    AvalancheMicroscopic aval;
    aval.SetSensor(sensor.get());
    aval.SetComponent(comp.get());
    aval.SetElectronStart(start_x, start_y, 0.0);

    // Compute drift and induced signal: this API varies with Garfield versions.
    // We'll run a microscopic drift and let the sensor compute the induced signal on the anode electrode we registered.
    aval.EnablePlotting(); // optional: will enable internal plotting hooks, needs display
    aval.TransportElectron(); // run the transport (will produce drift path & signals)

    // After transport, the sensor should have recorded signals. We can plot them:
    ViewSignal viewSignal;
    viewSignal.SetSensor(sensor.get());
    viewSignal.PlotSignal(0); // plot the first added electrode (our anode)

    // Also show drift lines
    ViewDrift viewDrift;
    viewDrift.SetSensor(sensor.get());
    viewDrift.PlotDrift(0); // plot the transport path (first drift)

    std::cout << "Simulation done. Check the ROOT canvases for field, drift and signal." << std::endl;

    return 0;
}
